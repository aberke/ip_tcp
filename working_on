NEIL:
state_machine -- done
window        -- struct that implements a very abstract, high-level version of the sliding window protocol -- almost done

Change Alex made to IP: We have added a type: TCP_DATA=6  which is the protocol number in the IP packet for TCP
					This is now defined where RIP_DATA and TEST_DATA defined

			
	We should think about what having only one ip_node means for the sliding window protocol (if only want one ip_node).

	tcp_node owns the following table:
		_________________________________ __ __ __
		int socket_id		| 	| 	|	|				<-- exactly what socket_api passes back when call socket(), accept() etc
		___________________________________________
		int port			|	|	|	|				<-- needs unique identifier for stdin 
		___________________________________________			int value assigned only once bind accept, or connect called
		struct tcp_connection|	|	|	|
		_____________________________________ _ ___ __

	int port: 	- need unique identifier for stdin
				- int value should only be assigned once bind() accept() or connect() called
				- assignment to port necessary for when receiving/sending tcp packets
					-- when handler calls on us to handle packet, we should know socket_id/tcp_connection
						 it corresponds to based on the tcp packet's destination port matching port in table


	struct tcp_connection:  (file added to git).
		int socket_id;
		tcp_socket_address_t local_addr;		-- it seems a socket is generally defined by 
		tcp_socket_address_t remote_addr;			its pair {(local ip, local port), (remote ip, remote port)}
			where:
				 struct tcp_socket_address{
					uint32_t virt_ip;	<--- what does this mean if listening on all interfaces??????
					uint16_t virt_port;
				};
			// doesn't need to know local ip
				needs to know remote ip for sending to ipnode
		
		handles own sliding window protocol?
		handles own state machine?
		
		has wrapper functions for sending packet and receiving packet
		
		to send a packet:
			sliding window protocol and the state machine need to somehow work in coordination
			the state machine has to be able to decide whether or not sending given packet in given way (connect() send())
				is legal
			-- how should this be done?
			- lastly the packet should go through a helper method that just wraps it appropriately in tcp_utils

start():

	create queue to_send	  --- tcp data for ip to send
	create queue to_read   --- tcp data that ip pushes on to queue for tcp to handle
	create queue stdin_commands --- some user commands to tcp_node driver need to be handled by ip_node
										like interfaces, up, down, etc
									enqueue and dequeues char* data types that are the buffered commands


	alex created ip_thread_data struct to pass in following arguments to start:
		struct ip_thread_data{
			ip_node_t ip_node;
			bqueue_t to_send;
			bqueue_t to_read;
			bqueue_t stdin_commands;
		};
			// data type that to_send and to_read queues will store (ie queue and dequeue) -- need vip's associated with packet
				typedef struct tcp_packet_data{
					uint32_t local_virt_ip;
					uint32_t remote_virt_ip;
					char packet[MTU];
					int packet_size;  //size of packet in bytes
				} tcp_packet_data_t;

***
tcp_node runs ip_node in 3 separate threads that handle different responsibilities and queues:
	ip_link_interface_thread:  reads off link interfaces (current select() loop) and throws packets for tcp to handle into to_read
	ip_send_thread: calls p_thread_cond_wait(&to_send) and sends things loaded on to queue
	ip_command_thread: calls p_thread_cond_wait(&stdin_commands) and handles ip commands loaded on to queue
	
	
			
NEIL:

TODO: THINK ABOUT DESIGN AND COMMUNICATE WITH ALEX PLEASE
please accomodate for new util files: circular_buffer.c, bqueue.c, node_readline.c, bq_list.h, node.c etc in makefile


ALEX:
	implement ***
	
	QUESTION: I malloc data structures to pass into threads -- where should those be freed?  within thread
	or within the function that created them?  -- important question since idk what happens if thread fails to create
	
	fix checksum!!!
	
