NEIL:
state_machine -- done
window        -- struct that implements a very abstract, high-level version of the sliding window protocol -- almost done

Change Alex made to IP: We have added a type: TCP_DATA=6  which is the protocol number in the IP packet for TCP
					This is now defined where RIP_DATA and TEST_DATA defined

BIG QUESTION:
	Can/should our tcp driver 'own' an ip_node (rather than the *node executable)?  
		- if owns *node exe. use popen? or use fopen?  why is this so badly documented on the internet???
	This could make our lives easier in the following way:
		- tp_driver could pass in a reference to itself so that the handler (when ip_node receives TCP_DATA)
				can directly call tcp_driver methods to handle the incoming packet.
		
		ramifications:  
			- This would change how we deal with standard input
			- when we want to send something, we'd need to somehow trigger stdin of ip_node to let it know,
				or we'd have to slightly change our implementation
				
				
Either way, I think our driver should have exactly one ip_node in the way described below

What are your feelings on this potential architecture:

	Let's say 'struct tcp_node' is our struct with the socket api and the struct that is 'driven' by the driver
	
	Why I believe one ip_node should serve all of the tcp connections:
		The specs say that even when a socket 'bind()'s' to a port, it should bind to all interfaces, etc
		Consider one ip_node serving all the tcp_connections so that when a TCP_DATA packet is received, 
			the ip_node passes off the packet to our tcp_node, tcp_node unwraps the packet, and based on 
			the destination port specified in the tcp-header, decides which struct tcp_connection the 
			packet was intended for.
			What are your thoughts?
			
	We should think about what having only one ip_node means for the sliding window protocol (if only want one ip_node).

	tcp_node owns the following table:
		_________________________________ __ __ __
		int socket_id		| 	| 	|	|				<-- exactly what socket_api passes back when call socket(), accept() etc
		___________________________________________
		int port			|	|	|	|				<-- needs unique identifier for stdin 
		___________________________________________			int value assigned only once bind accept, or connect called
		struct tcp_connection|	|	|	|
		_____________________________________ _ ___ __

	int port: 	- need unique identifier for stdin
				- int value should only be assigned once bind() accept() or connect() called
				- assignment to port necessary for when receiving/sending tcp packets
					-- when handler calls on us to handle packet, we should know socket_id/tcp_connection
						 it corresponds to based on the tcp packet's destination port matching port in table


	struct tcp_connection:  (file added to git).
		int socket_id;
		tcp_socket_address_t local_addr;		-- it seems a socket is generally defined by 
		tcp_socket_address_t remote_addr;			its pair {(local ip, local port), (remote ip, remote port)}
			where:
				 struct tcp_socket_address{
					uint32_t virt_ip;	<--- what does this mean if listening on all interfaces??????
					uint16_t virt_port;
				};
			// doesn't need to know local ip
				needs to know remote ip for sending to ipnode
		
		handles own sliding window protocol?
		handles own state machine?
		
		has wrapper functions for sending packet and receiving packet
		
		to send a packet:
			sliding window protocol and the state machine need to somehow work in coordination
			the state machine has to be able to decide whether or not sending given packet in given way (connect() send())
				is legal
			-- how should this be done?
			- lastly the packet should go through a helper method that just wraps it appropriately in tcp_utils

start():

	create queue to_send	  --- tcp data for ip to send
	create queue to_receive   --- tcp data that ip pushes on to queue for tcp to handle
	create queue stdin_commands --- some user commands to tcp_node driver need to be handled by ip_node
										like interfaces, up, down, etc
									enqueue and dequeues char* data types that are the buffered commands


	alex created ip_thread_data struct to pass in following arguments to start:
		struct ip_thread_data{
			ip_node_t ip_node;
			bqueue_t to_send;
			bqueue_t to_read;
			bqueue_t stdin_commands;
		};
			// data type that to_send and to_read queues will store (ie queue and dequeue) -- need vip's associated with packet
				typedef struct tcp_packet_data{
					uint32_t local_virt_ip;
					uint32_t remote_virt_ip;
					char packet[MTU];
					int packet_size;  //size of packet in bytes
				} tcp_packet_data_t;








				
NEIL:

TODO: THINK ABOUT DESIGN AND COMMUNICATE WITH ALEX PLEASE
please accomodate for new util files: circular_buffer.c, bqueue.c, node_readline.c, bq_list.h, node.c etc in makefile


ALEX:
	- added the tcp directory to include/ and src/
	- added file tcp_node.h and tcp_node.c as our struct that is analogous to struct ip_node
	

